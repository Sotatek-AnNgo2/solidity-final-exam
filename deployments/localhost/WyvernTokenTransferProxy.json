{
  "address": "0x0165878A594ca255338adfa4d48449f69242Eb8F",
  "abi": [
    {
      "constant": false,
      "inputs": [
        {
          "name": "token",
          "type": "address"
        },
        {
          "name": "from",
          "type": "address"
        },
        {
          "name": "to",
          "type": "address"
        },
        {
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "name": "",
          "type": "bool"
        }
      ],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "constant": true,
      "inputs": [],
      "name": "registry",
      "outputs": [
        {
          "name": "",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "name": "registryAddr",
          "type": "address"
        }
      ],
      "payable": false,
      "stateMutability": "nonpayable",
      "type": "constructor"
    }
  ],
  "transactionHash": "0xad43d63e2cccef265537387d4bff39a7901f14c744603ac303dd4d36038719b5",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0x0165878A594ca255338adfa4d48449f69242Eb8F",
    "transactionIndex": 0,
    "gasUsed": "215578",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x15f8428f67b0742f7792ec2c5c3e392f6f9d9fb267098987e1dc02bd1bec3951",
    "transactionHash": "0xad43d63e2cccef265537387d4bff39a7901f14c744603ac303dd4d36038719b5",
    "logs": [],
    "blockNumber": 7,
    "cumulativeGasUsed": "215578",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5FC8d32690cc91D4c39d9d3abcBD16989F875707"
  ],
  "numDeployments": 1,
  "solcInputHash": "81c416fcc09f009c489a7d6d5627b21d",
  "metadata": "{\"compiler\":{\"version\":\"0.4.26+commit.4563c3fc\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"registryAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}],\"devdoc\":{\"methods\":{\"transferFrom(address,address,address,uint256)\":{\"details\":\"Authenticated contract only\\r\",\"params\":{\"amount\":\"Transfer amount\\r\",\"from\":\"From address\\r\",\"to\":\"To address\\r\",\"token\":\"ERC20 token address\\r\"}}}},\"userdoc\":{\"methods\":{\"transferFrom(address,address,address,uint256)\":{\"notice\":\"Call ERC20 `transferFrom`\\r \"}}}},\"settings\":{\"compilationTarget\":{\"contracts/WyvernTokenTransferProxy.sol\":\"WyvernTokenTransferProxy\"},\"evmVersion\":\"byzantium\",\"libraries\":{},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/WyvernTokenTransferProxy.sol\":{\"content\":\"pragma solidity ^0.4.13;\\r\\n\\r\\nimport { TokenTransferProxy } from \\\"./registry/TokenTransferProxy.sol\\\";\\r\\nimport { ProxyRegistry } from \\\"./registry/ProxyRegistry.sol\\\";\\r\\n\\r\\ncontract WyvernTokenTransferProxy is TokenTransferProxy {\\r\\n\\r\\n    constructor (ProxyRegistry registryAddr)\\r\\n        public\\r\\n    {\\r\\n        registry = registryAddr;\\r\\n    }\\r\\n\\r\\n}\\r\\n\",\"keccak256\":\"0x83a136289aa1516f0a9beef257e2d01ee69a4d36204e0971e851385dacf23445\"},\"contracts/libraries/ERC20.sol\":{\"content\":\"pragma solidity ^0.4.13;\\r\\n\\r\\nimport { SafeMath } from \\\"../libraries/SafeMath.sol\\\";\\r\\n\\r\\ncontract ERC20Basic {\\r\\n  uint256 public totalSupply;\\r\\n  function balanceOf(address who) public view returns (uint256);\\r\\n  function transfer(address to, uint256 value) public returns (bool);\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n}\\r\\n\\r\\ncontract BasicToken is ERC20Basic {\\r\\n  using SafeMath for uint256;\\r\\n\\r\\n  mapping(address => uint256) balances;\\r\\n\\r\\n  /**\\r\\n  * @dev transfer token for a specified address\\r\\n  * @param _to The address to transfer to.\\r\\n  * @param _value The amount to be transferred.\\r\\n  */\\r\\n  function transfer(address _to, uint256 _value) public returns (bool) {\\r\\n    require(_to != address(0));\\r\\n    require(_value <= balances[msg.sender]);\\r\\n\\r\\n    // SafeMath.sub will throw if there is not enough balance.\\r\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\r\\n    balances[_to] = balances[_to].add(_value);\\r\\n    emit Transfer(msg.sender, _to, _value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Gets the balance of the specified address.\\r\\n  * @param _owner The address to query the the balance of.\\r\\n  * @return An uint256 representing the amount owned by the passed address.\\r\\n  */\\r\\n  function balanceOf(address _owner) public view returns (uint256 balance) {\\r\\n    return balances[_owner];\\r\\n  }\\r\\n\\r\\n}\\r\\n\\r\\ncontract ERC20 is ERC20Basic {\\r\\n  function allowance(address owner, address spender) public view returns (uint256);\\r\\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\\r\\n  function approve(address spender, uint256 value) public returns (bool);\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\ncontract StandardToken is ERC20, BasicToken {\\r\\n\\r\\n  mapping (address => mapping (address => uint256)) internal allowed;\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Transfer tokens from one address to another\\r\\n   * @param _from address The address which you want to send tokens from\\r\\n   * @param _to address The address which you want to transfer to\\r\\n   * @param _value uint256 the amount of tokens to be transferred\\r\\n   */\\r\\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\\r\\n    require(_to != address(0));\\r\\n    require(_value <= balances[_from]);\\r\\n    require(_value <= allowed[_from][msg.sender]);\\r\\n\\r\\n    balances[_from] = balances[_from].sub(_value);\\r\\n    balances[_to] = balances[_to].add(_value);\\r\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\r\\n    emit Transfer(_from, _to, _value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\r\\n   *\\r\\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\\r\\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\r\\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\r\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n   * @param _spender The address which will spend the funds.\\r\\n   * @param _value The amount of tokens to be spent.\\r\\n   */\\r\\n  function approve(address _spender, uint256 _value) public returns (bool) {\\r\\n    allowed[msg.sender][_spender] = _value;\\r\\n    emit Approval(msg.sender, _spender, _value);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\\r\\n   * @param _owner address The address which owns the funds.\\r\\n   * @param _spender address The address which will spend the funds.\\r\\n   * @return A uint256 specifying the amount of tokens still available for the spender.\\r\\n   */\\r\\n  function allowance(address _owner, address _spender) public view returns (uint256) {\\r\\n    return allowed[_owner][_spender];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * approve should be called when allowed[_spender] == 0. To increment\\r\\n   * allowed value is better to use this function to avoid 2 calls (and wait until\\r\\n   * the first transaction is mined)\\r\\n   * From MonolithDAO Token.sol\\r\\n   */\\r\\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\\r\\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\\r\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\\r\\n    uint oldValue = allowed[msg.sender][_spender];\\r\\n    if (_subtractedValue > oldValue) {\\r\\n      allowed[msg.sender][_spender] = 0;\\r\\n    } else {\\r\\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\\r\\n    }\\r\\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n}\",\"keccak256\":\"0xf741640379eccbda58f19ddb57a2bb26719faff6734de5543f7585382dd63ba5\"},\"contracts/libraries/Ownable.sol\":{\"content\":\"pragma solidity 0.4.26;\\r\\n\\r\\ncontract Ownable {\\r\\n  address public owner;\\r\\n\\r\\n\\r\\n  event OwnershipRenounced(address indexed previousOwner);\\r\\n  event OwnershipTransferred(\\r\\n    address indexed previousOwner,\\r\\n    address indexed newOwner\\r\\n  );\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\r\\n   * account.\\r\\n   */\\r\\n  constructor() public {\\r\\n    owner = msg.sender;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Throws if called by any account other than the owner.\\r\\n   */\\r\\n  modifier onlyOwner() {\\r\\n    require(msg.sender == owner);\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n   * @param newOwner The address to transfer ownership to.\\r\\n   */\\r\\n  function transferOwnership(address newOwner) public onlyOwner {\\r\\n    require(newOwner != address(0));\\r\\n    emit OwnershipTransferred(owner, newOwner);\\r\\n    owner = newOwner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows the current owner to relinquish control of the contract.\\r\\n   */\\r\\n  function renounceOwnership() public onlyOwner {\\r\\n    emit OwnershipRenounced(owner);\\r\\n    owner = address(0);\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x8be1863b3ecd995f35ec012b1b63dcedeecdd340006b27689338b8121a7bbb84\"},\"contracts/libraries/SafeMath.sol\":{\"content\":\"pragma solidity 0.4.26;\\r\\n\\r\\nlibrary SafeMath {\\r\\n\\r\\n  /**\\r\\n  * @dev Multiplies two numbers, throws on overflow.\\r\\n  */\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n    if (a == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    c = a * b;\\r\\n    assert(c / a == b);\\r\\n    return c;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Integer division of two numbers, truncating the quotient.\\r\\n  */\\r\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\\r\\n    // uint256 c = a / b;\\r\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\r\\n    return a / b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\r\\n  */\\r\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n    assert(b <= a);\\r\\n    return a - b;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Adds two numbers, throws on overflow.\\r\\n  */\\r\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\r\\n    c = a + b;\\r\\n    assert(c >= a);\\r\\n    return c;\\r\\n  }\\r\\n}\",\"keccak256\":\"0xedb0e1081827d01b6928b4685641e765662e24960b4c8999de7fad7668ba3a82\"},\"contracts/registry/OwnableDelegateProxy.sol\":{\"content\":\"pragma solidity ^0.4.13;\\r\\n\\r\\nimport { OwnedUpgradeabilityProxy } from \\\"./proxy/OwnedUpgradeabilityProxy.sol\\\";\\r\\n\\r\\ncontract OwnableDelegateProxy is OwnedUpgradeabilityProxy {\\r\\n\\r\\n    constructor(address owner, address initialImplementation, bytes calldata)\\r\\n        public\\r\\n    {\\r\\n        setUpgradeabilityOwner(owner);\\r\\n        _upgradeTo(initialImplementation);\\r\\n        require(initialImplementation.delegatecall(calldata));\\r\\n    }\\r\\n\\r\\n}\",\"keccak256\":\"0x447c946441bc828a0b0b90697d2ec0a0e77ea840fc251db5deedca81226970bf\"},\"contracts/registry/ProxyRegistry.sol\":{\"content\":\"/*\\r\\n\\r\\n  Proxy registry; keeps a mapping of AuthenticatedProxy contracts and mapping of contracts authorized to access them.  \\r\\n  \\r\\n  Abstracted away from the Exchange (a) to reduce Exchange attack surface and (b) so that the Exchange contract can be upgraded without users needing to transfer assets to new proxies.\\r\\n\\r\\n*/\\r\\n\\r\\npragma solidity ^0.4.13;\\r\\n\\r\\nimport { Ownable } from \\\"../libraries/Ownable.sol\\\";\\r\\nimport { OwnableDelegateProxy } from \\\"./OwnableDelegateProxy.sol\\\";\\r\\n\\r\\ncontract ProxyRegistry is Ownable {\\r\\n\\r\\n    /* DelegateProxy implementation contract. Must be initialized. */\\r\\n    address public delegateProxyImplementation;\\r\\n\\r\\n    /* Authenticated proxies by user. */\\r\\n    mapping(address => OwnableDelegateProxy) public proxies;\\r\\n\\r\\n    /* Contracts pending access. */\\r\\n    mapping(address => uint) public pending;\\r\\n\\r\\n    /* Contracts allowed to call those proxies. */\\r\\n    mapping(address => bool) public contracts;\\r\\n\\r\\n    /* Delay period for adding an authenticated contract.\\r\\n       This mitigates a particular class of potential attack on the Wyvern DAO (which owns this registry) - if at any point the value of assets held by proxy contracts exceeded the value of half the WYV supply (votes in the DAO),\\r\\n       a malicious but rational attacker could buy half the Wyvern and grant themselves access to all the proxy contracts. A delay period renders this attack nonthreatening - given two weeks, if that happened, users would have\\r\\n       plenty of time to notice and transfer their assets.\\r\\n    */\\r\\n    uint public DELAY_PERIOD = 1 minutes;\\r\\n\\r\\n    /**\\r\\n     * Start the process to enable access for specified contract. Subject to delay period.\\r\\n     *\\r\\n     * @dev ProxyRegistry owner only\\r\\n     * @param addr Address to which to grant permissions\\r\\n     */\\r\\n    function startGrantAuthentication (address addr)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(!contracts[addr] && pending[addr] == 0);\\r\\n        pending[addr] = now;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * End the process to nable access for specified contract after delay period has passed.\\r\\n     *\\r\\n     * @dev ProxyRegistry owner only\\r\\n     * @param addr Address to which to grant permissions\\r\\n     */\\r\\n    function endGrantAuthentication (address addr)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(!contracts[addr] && pending[addr] != 0 && ((pending[addr] + DELAY_PERIOD) < now));\\r\\n        pending[addr] = 0;\\r\\n        contracts[addr] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Revoke access for specified contract. Can be done instantly.\\r\\n     *\\r\\n     * @dev ProxyRegistry owner only\\r\\n     * @param addr Address of which to revoke permissions\\r\\n     */    \\r\\n    function revokeAuthentication (address addr)\\r\\n        public\\r\\n        onlyOwner\\r\\n    {\\r\\n        contracts[addr] = false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Register a proxy contract with this registry\\r\\n     *\\r\\n     * @dev Must be called by the user which the proxy is for, creates a new AuthenticatedProxy\\r\\n     * @return New AuthenticatedProxy contract\\r\\n     */\\r\\n    function registerProxy()\\r\\n        public\\r\\n        returns (OwnableDelegateProxy proxy)\\r\\n    {\\r\\n        require(proxies[msg.sender] == address(0));\\r\\n        proxy = new OwnableDelegateProxy(msg.sender, delegateProxyImplementation, abi.encodeWithSignature(\\\"initialize(address,address)\\\", msg.sender, address(this)));\\r\\n        proxies[msg.sender] = proxy;\\r\\n        return proxy;\\r\\n    }\\r\\n\\r\\n}\\r\\n\",\"keccak256\":\"0xbd7a7d2d0ddf1f4c7c56f90a46ee9eb3100e6fcc9a617ed7e07856f6502fb4c1\"},\"contracts/registry/TokenTransferProxy.sol\":{\"content\":\"/*\\r\\n\\r\\n  Token transfer proxy. Uses the authentication table of a ProxyRegistry contract to grant ERC20 `transferFrom` access.\\r\\n  This means that users only need to authorize the proxy contract once for all future protocol versions.\\r\\n\\r\\n*/\\r\\n\\r\\npragma solidity ^0.4.13;\\r\\n\\r\\nimport { ERC20 } from \\\"../libraries/ERC20.sol\\\";\\r\\nimport { ProxyRegistry } from \\\"./ProxyRegistry.sol\\\";\\r\\n\\r\\ncontract TokenTransferProxy {\\r\\n\\r\\n    /* Authentication registry. */\\r\\n    ProxyRegistry public registry;\\r\\n\\r\\n    /**\\r\\n     * Call ERC20 `transferFrom`\\r\\n     *\\r\\n     * @dev Authenticated contract only\\r\\n     * @param token ERC20 token address\\r\\n     * @param from From address\\r\\n     * @param to To address\\r\\n     * @param amount Transfer amount\\r\\n     */\\r\\n    function transferFrom(address token, address from, address to, uint amount)\\r\\n        public\\r\\n        returns (bool)\\r\\n    {\\r\\n        require(registry.contracts(msg.sender));\\r\\n        return ERC20(token).transferFrom(from, to, amount);\\r\\n    }\\r\\n\\r\\n}\",\"keccak256\":\"0x195b426dc98cddeb91ebd8664267c098319809550a3d952017c8ec3ae958c077\"},\"contracts/registry/proxy/OwnedUpgradeabilityProxy.sol\":{\"content\":\"pragma solidity ^0.4.13;\\r\\n\\r\\nimport './Proxy.sol';\\r\\nimport './OwnedUpgradeabilityStorage.sol';\\r\\n\\r\\n/**\\r\\n * @title OwnedUpgradeabilityProxy\\r\\n * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\\r\\n */\\r\\ncontract OwnedUpgradeabilityProxy is Proxy, OwnedUpgradeabilityStorage {\\r\\n  /**\\r\\n  * @dev Event to show ownership has been transferred\\r\\n  * @param previousOwner representing the address of the previous owner\\r\\n  * @param newOwner representing the address of the new owner\\r\\n  */\\r\\n  event ProxyOwnershipTransferred(address previousOwner, address newOwner);\\r\\n\\r\\n  /**\\r\\n  * @dev This event will be emitted every time the implementation gets upgraded\\r\\n  * @param implementation representing the address of the upgraded implementation\\r\\n  */\\r\\n  event Upgraded(address indexed implementation);\\r\\n\\r\\n  /**\\r\\n  * @dev Upgrades the implementation address\\r\\n  * @param implementation representing the address of the new implementation to be set\\r\\n  */\\r\\n  function _upgradeTo(address implementation) internal {\\r\\n    require(_implementation != implementation);\\r\\n    _implementation = implementation;\\r\\n    emit Upgraded(implementation);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Throws if called by any account other than the owner.\\r\\n  */\\r\\n  modifier onlyProxyOwner() {\\r\\n    require(msg.sender == proxyOwner());\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Tells the address of the proxy owner\\r\\n   * @return the address of the proxy owner\\r\\n   */\\r\\n  function proxyOwner() public view returns (address) {\\r\\n    return upgradeabilityOwner();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\\r\\n   * @param newOwner The address to transfer ownership to.\\r\\n   */\\r\\n  function transferProxyOwnership(address newOwner) public onlyProxyOwner {\\r\\n    require(newOwner != address(0));\\r\\n    emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\\r\\n    setUpgradeabilityOwner(newOwner);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows the upgradeability owner to upgrade the current implementation of the proxy.\\r\\n   * @param implementation representing the address of the new implementation to be set.\\r\\n   */\\r\\n  function upgradeTo(address implementation) public onlyProxyOwner {\\r\\n    _upgradeTo(implementation);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Allows the upgradeability owner to upgrade the current implementation of the proxy\\r\\n   * and delegatecall the new implementation for initialization.\\r\\n   * @param implementation representing the address of the new implementation to be set.\\r\\n   * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function\\r\\n   * signature of the implementation to be called with the needed payload\\r\\n   */\\r\\n  function upgradeToAndCall(address implementation, bytes data) payable public onlyProxyOwner {\\r\\n    upgradeTo(implementation);\\r\\n    require(address(this).delegatecall(data));\\r\\n  }\\r\\n}\",\"keccak256\":\"0xf8ed7d84ec9ea7bacfd0faebae8e8c538e36a21d30280fcd01b2ae433161e48f\"},\"contracts/registry/proxy/OwnedUpgradeabilityStorage.sol\":{\"content\":\"pragma solidity ^0.4.13;\\r\\n\\r\\n/**\\r\\n * @title OwnedUpgradeabilityStorage\\r\\n * @dev This contract keeps track of the upgradeability owner\\r\\n */\\r\\ncontract OwnedUpgradeabilityStorage {\\r\\n\\r\\n  // Current implementation\\r\\n  address internal _implementation;\\r\\n\\r\\n  // Owner of the contract\\r\\n  address private _upgradeabilityOwner;\\r\\n\\r\\n  /**\\r\\n   * @dev Tells the address of the owner\\r\\n   * @return the address of the owner\\r\\n   */\\r\\n  function upgradeabilityOwner() public view returns (address) {\\r\\n    return _upgradeabilityOwner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets the address of the owner\\r\\n   */\\r\\n  function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {\\r\\n    _upgradeabilityOwner = newUpgradeabilityOwner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Tells the address of the current implementation\\r\\n  * @return address of the current implementation\\r\\n  */\\r\\n  function implementation() public view returns (address) {\\r\\n    return _implementation;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Tells the proxy type (EIP 897)\\r\\n  * @return Proxy type, 2 for forwarding proxy\\r\\n  */\\r\\n  function proxyType() public pure returns (uint256 proxyTypeId) {\\r\\n    return 2;\\r\\n  }\\r\\n}\",\"keccak256\":\"0xfee90e128992c6321344e1d74bf37cc94bce07cdcaf97af55c980780b31a3959\"},\"contracts/registry/proxy/Proxy.sol\":{\"content\":\"pragma solidity ^0.4.13;\\r\\n\\r\\n/**\\r\\n * @title Proxy\\r\\n * @dev Gives the possibility to delegate any call to a foreign implementation.\\r\\n */\\r\\ncontract Proxy {\\r\\n\\r\\n  /**\\r\\n  * @dev Tells the address of the implementation where every call will be delegated.\\r\\n  * @return address of the implementation to which it will be delegated\\r\\n  */\\r\\n  function implementation() public view returns (address);\\r\\n\\r\\n  /**\\r\\n  * @dev Tells the type of proxy (EIP 897)\\r\\n  * @return Type of proxy, 2 for upgradeable proxy\\r\\n  */\\r\\n  function proxyType() public pure returns (uint256 proxyTypeId);\\r\\n\\r\\n  /**\\r\\n  * @dev Fallback function allowing to perform a delegatecall to the given implementation.\\r\\n  * This function will return whatever the implementation call returns\\r\\n  */\\r\\n  function () payable public {\\r\\n    address _impl = implementation();\\r\\n    require(_impl != address(0));\\r\\n\\r\\n    assembly {\\r\\n      let ptr := mload(0x40)\\r\\n      calldatacopy(ptr, 0, calldatasize)\\r\\n      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\\r\\n      let size := returndatasize\\r\\n      returndatacopy(ptr, 0, size)\\r\\n\\r\\n      switch result\\r\\n      case 0 { revert(ptr, size) }\\r\\n      default { return(ptr, size) }\\r\\n    }\\r\\n  }\\r\\n}\",\"keccak256\":\"0x501fa6d387050a7ae7d855576852b427b9d5de35c6550f4d2bf64cf00b31a0ec\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b506040516020806102d9833981016040525160008054600160a060020a03909216600160a060020a0319909216919091179055610287806100526000396000f30060806040526004361061004b5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166315dacbea81146100505780637b103999146100a1575b600080fd5b34801561005c57600080fd5b5061008d73ffffffffffffffffffffffffffffffffffffffff600435811690602435811690604435166064356100df565b604080519115158252519081900360200190f35b3480156100ad57600080fd5b506100b661023f565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b60008054604080517f69dc9ff3000000000000000000000000000000000000000000000000000000008152336004820152905173ffffffffffffffffffffffffffffffffffffffff909216916369dc9ff39160248082019260209290919082900301818787803b15801561015257600080fd5b505af1158015610166573d6000803e3d6000fd5b505050506040513d602081101561017c57600080fd5b5051151561018957600080fd5b604080517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86811660048301528581166024830152604482018590529151918716916323b872dd916064808201926020929091908290030181600087803b15801561020a57600080fd5b505af115801561021e573d6000803e3d6000fd5b505050506040513d602081101561023457600080fd5b505195945050505050565b60005473ffffffffffffffffffffffffffffffffffffffff16815600a165627a7a72305820246ab6c840638cda1a0b26f3e56658eb26a5a777ec7c1e7e188c43096fca45a30029",
  "deployedBytecode": "0x60806040526004361061004b5763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166315dacbea81146100505780637b103999146100a1575b600080fd5b34801561005c57600080fd5b5061008d73ffffffffffffffffffffffffffffffffffffffff600435811690602435811690604435166064356100df565b604080519115158252519081900360200190f35b3480156100ad57600080fd5b506100b661023f565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b60008054604080517f69dc9ff3000000000000000000000000000000000000000000000000000000008152336004820152905173ffffffffffffffffffffffffffffffffffffffff909216916369dc9ff39160248082019260209290919082900301818787803b15801561015257600080fd5b505af1158015610166573d6000803e3d6000fd5b505050506040513d602081101561017c57600080fd5b5051151561018957600080fd5b604080517f23b872dd00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff86811660048301528581166024830152604482018590529151918716916323b872dd916064808201926020929091908290030181600087803b15801561020a57600080fd5b505af115801561021e573d6000803e3d6000fd5b505050506040513d602081101561023457600080fd5b505195945050505050565b60005473ffffffffffffffffffffffffffffffffffffffff16815600a165627a7a72305820246ab6c840638cda1a0b26f3e56658eb26a5a777ec7c1e7e188c43096fca45a30029",
  "devdoc": {
    "methods": {
      "transferFrom(address,address,address,uint256)": {
        "details": "Authenticated contract only\r",
        "params": {
          "amount": "Transfer amount\r",
          "from": "From address\r",
          "to": "To address\r",
          "token": "ERC20 token address\r"
        }
      }
    }
  },
  "userdoc": {
    "methods": {
      "transferFrom(address,address,address,uint256)": {
        "notice": "Call ERC20 `transferFrom`\r "
      }
    }
  }
}